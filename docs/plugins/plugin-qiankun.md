# @umijs/plugin-qiankun


Umi plugin for [qiankun](https://github.com/umijs/qiankun).

## Examples

Navigation is the main application, App1 and App2 are sub-applications,

![](https://img.alicdn.com/tfs/TB1ZMxEwKH2gK0jSZJnXXaT1FXa-1040-619.gif)

## Features

- ✔︎ Based on qiankun
- ✔︎ Supports main and sub-applications using umi
- ✔︎ Support master and sub-application browser, hash and other history modes
- ✔︎ Parent-child communication
- ✔︎ Configure custom `bootstrap()`, `mount()`, and `unmount()` at child application runtime
- ✔︎ Main application and sub application joint debugging

## Usage

### Main application

#### Construction period

```js
export default {
  qiankun: {
    master: {
      // Register child app information
      apps: [
        {
          name: 'app1', // Unique id
          entry: '//localhost:7001', // html entry
          base: '/app1', // app1's routing prefix. Use this prefix to determine whether to start the application, which is usually the same as the base of the sub-application.
          history: 'browser', // Child application history configuration, default is the current main application history configuration
        },
        {
          name: 'app2',
          entry: {
            // TODO: support config entry
            scripts: [],
            styles: [],
          },
          base: '/app2',
        },
      ],
      jsSandbox: true, // Whether to enable js sandbox, default is false
      prefetch: true, // Whether to enable prefetch feature, default is true
    },
  },
};
```

Note: When the history mode of the main application is the same as that of the sub-application (such as browser or hash), the plugin will automatically create some empty routes to avoid 404. Therefore, it is recommended that the main application and the sub-application use the same history mode, otherwise you need to handle these situations .

#### Runtime

##### 1. src/app.js Configuration

```js
// Get the sub-application configuration from the interface. The qiankun variable exported is a Promise
export const qiankun = fetch('/config').then(({ apps }) => ({
  // Register child app information
  apps,
  jsSandbox: true, // Whether to enable js sandbox, default is false
  prefetch: true, // Whether to enable prefetch feature, default is true
  lifeCycles: {
    // see https://github.com/umijs/qiankun#registermicroapps
    afterMount: props => {
      console.log(props);
    },
  },
  // ...even more options qiankun start() supported, see https://github.com/umijs/qiankun#start
}));
```

##### 2. Add child application route

由于 umi 不支持在应用 render 之后修改路由，故运行时配置方式插件无法自动生成子应用相关路由，（见[代码](https://github.com/umijs/umi-plugin-qiankun/blob/master/src/master/index.ts#L34)）。所以这里需要用户手动添加子应用相关路由配置避免 404 情况：

###### 2.1 New main application pages/subAppContainer.js

```js
import React from 'react';

export default function() {
  return <div />;
}
```

###### 2.2 New pages/subAppContainer.js

```js
// Add sub-app related routing configuration in main app config.js
export default {
  routes: [
    { path: '/app1', exact: true, component: 'subAppContainer' },
    { path: '/app2', exact: true, component: 'subAppContainer' },
  ],
};
```

### Configuration list

| Configuration | Description | Type | Is required | Default |
| --- | --- | --- | --- | --- |
| apps | Sub-application configuration | App[] | Yes |  |
| jsSandbox | Whether to enable the js sandbox | boolean | no | false |
| prefetch | Whether to enable the prefetch feature | boolean | no | true |
| defer | Whether to render asynchronously. For example, the rendering container of a child application depends on the node generated by the main application, and the process of generating the node by the main application is asynchronous. <br />When this configuration is enabled, qiankun needs to be notified using the `import { qiankunStart } from 'umi'` api. Reference [example](https://github.com/umijs/umi-plugin-qiankun/blob/master/examples/master/models/base.js#L35) | boolean | no | false |

[qiankun start](https://github.com/umijs/qiankun#start) Other acceptable parameters of the method can also be configured here

#### App

| Configuration | Description | Type | Is required | Default |
| --- | --- | --- | --- | --- |
| name | Child app unique id | string | Yes |  |
| entry | Child application html address | string \| { script: string[], styles: [] } | Yes |  |
| base | The sub application routing prefix is ​​usually the same as the [base configuration](https://umijs.org/config/#base) of the sub application. The framework will use this configuration as a prefix to determine whether to activate the current application. It supports the configuration of a set of prefix | string \| string[] | Yes |  |
| history | [umi history mode](https://umijs.org/config/#history) | string | no | Main application history configuration |
| mountElementId | Which id node of the main application the child application is mounted on (note that it is not the same as the mountElementId of the child application) | string | no | root-subapp |
| props | Data passed from main application to child applications | object | no | {} |

### Sub-application

```js
export default {
  base: `/${appName}`, // The child's base, which defaults to the name field in package.json
  plugins: ['@umijs/plugin-qiankun', { slave: {} }],
};
```

If the child application configuration item is empty, that is, slave: {}, you can omit the configuration:

```js
export default {
  base: `/${appName}`, // The child's base, which defaults to the name field in package.json
  plugins: ['@umijs/plugin-qiankun'],
};
```

#### Environment variable configuration

In order to obtain a better local development and debugging experience, we recommend that you specify the specific port number for the application startup in the sub-application in advance, such as specified by `.env`

```yml
PORT=8081
```

Detailed configuration reference: https://umijs.org/zh/guide/env-variables.html#port

## Parent-child communication

There are two ways to achieve this

### Props based

Scheme similar to communication between components in react

1. When the apps are configured in the main application, data is passed as props (refer to the main application runtime configuration section)

   ```js
   // src/app.js

   export const qiankun = fetch('/config').then(config => {
     return {
       apps: [
         {
           name: 'app1',
           entry: '//localhost:2222',
           base: '/app1',
           props: {
             onClick: event => console.log(event),
             ...config,
           },
         },
       ],
     };
   });
   ```

2. The child application gets the props consumption data in the lifecycle hook (refer to the sub-application runtime configuration section)

### Hooks-based data sharing

Since the solution is based on react hooks, the relevant APIs can only be used in functional components, not in class components.

1.Convention in the parent application to export content in `src/rootExports.js`
2. In the sub-application, use `import { useRootExports } from 'umi'; const rootExports = useRootExports();`

## Child application runtime configuration

Output `qiankun` in` src/app.js` of the sub-application, `props` is provided by the main application when registering the sub-application

```js
export const qiankun = {
  // Before the app loads
  async bootstrap(props) {
    console.log('app1 bootstrap', props);
  },
  // Fires before applying render
  async mount(props) {
    console.log('app1 mount', props);
  },
  // Triggered after app uninstall
  async unmount(props) {
    console.log('app1 unmount', props);
  },
};
```

## Related

- [RFC: Micro Frontend (@umijs/plugin-qiankun) by sorrycc · Pull Request #3 · umijs/rfcs · GitHub](https://github.com/umijs/rfcs/pull/3)
- [umi-example-monorepo](https://github.com/umijs/umi-example-monorepo) Another simple and rough micro-front end experiment I tried before
